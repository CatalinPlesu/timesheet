//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        // MODIFIED: Removed trailing slash to prevent double-slash in URLs (//api/...)
        this.baseUrl = baseUrl ?? "http://localhost:5191";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return OK
     */
    dailyAverages(startDate?: Date | undefined, endDate?: Date | undefined): Promise<DailyAveragesDto> {
        let url_ = this.baseUrl + "/api/Analytics/daily-averages?";
        if (startDate === null)
            throw new globalThis.Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new globalThis.Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDailyAverages(_response);
        });
    }

    protected processDailyAverages(response: Response): Promise<DailyAveragesDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DailyAveragesDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DailyAveragesDto>(null as any);
    }

    /**
     * @param direction (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return OK
     */
    commutePatterns(direction?: string | undefined, startDate?: Date | undefined, endDate?: Date | undefined): Promise<CommutePatternsDto[]> {
        let url_ = this.baseUrl + "/api/Analytics/commute-patterns?";
        if (direction === null)
            throw new globalThis.Error("The parameter 'direction' cannot be null.");
        else if (direction !== undefined)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&";
        if (startDate === null)
            throw new globalThis.Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new globalThis.Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCommutePatterns(_response);
        });
    }

    protected processCommutePatterns(response: Response): Promise<CommutePatternsDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommutePatternsDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommutePatternsDto[]>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return OK
     */
    periodAggregate(startDate?: Date | undefined, endDate?: Date | undefined): Promise<PeriodAggregateDto> {
        let url_ = this.baseUrl + "/api/Analytics/period-aggregate?";
        if (startDate === null)
            throw new globalThis.Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new globalThis.Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPeriodAggregate(_response);
        });
    }

    protected processPeriodAggregate(response: Response): Promise<PeriodAggregateDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PeriodAggregateDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PeriodAggregateDto>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return OK
     */
    dailyBreakdown(startDate?: Date | undefined, endDate?: Date | undefined): Promise<DailyBreakdownDto[]> {
        let url_ = this.baseUrl + "/api/Analytics/daily-breakdown?";
        if (startDate === null)
            throw new globalThis.Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new globalThis.Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDailyBreakdown(_response);
        });
    }

    protected processDailyBreakdown(response: Response): Promise<DailyBreakdownDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DailyBreakdownDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DailyBreakdownDto[]>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param groupBy (optional) 
     * @return OK
     */
    chartData(startDate?: Date | undefined, endDate?: Date | undefined, groupBy?: string | undefined): Promise<ChartDataDto> {
        let url_ = this.baseUrl + "/api/Analytics/chart-data?";
        if (startDate === null)
            throw new globalThis.Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new globalThis.Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (groupBy === null)
            throw new globalThis.Error("The parameter 'groupBy' cannot be null.");
        else if (groupBy !== undefined)
            url_ += "groupBy=" + encodeURIComponent("" + groupBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChartData(_response);
        });
    }

    protected processChartData(response: Response): Promise<ChartDataDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChartDataDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChartDataDto>(null as any);
    }

    /**
     * @return OK
     */
    login(body: LoginRequest): Promise<LoginResponse> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<LoginResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoginResponse>(null as any);
    }

    /**
     * @return OK
     */
    refresh(body: RefreshTokenRequest): Promise<LoginResponse> {
        let url_ = this.baseUrl + "/api/Auth/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefresh(_response);
        });
    }

    protected processRefresh(response: Response): Promise<LoginResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoginResponse>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param groupBy (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    entriesGET(startDate?: Date | undefined, endDate?: Date | undefined, groupBy?: number | undefined, page?: number | undefined, pageSize?: number | undefined): Promise<EntryListResponse> {
        let url_ = this.baseUrl + "/api/Entries?";
        if (startDate === null)
            throw new globalThis.Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new globalThis.Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (groupBy === null)
            throw new globalThis.Error("The parameter 'groupBy' cannot be null.");
        else if (groupBy !== undefined)
            url_ += "GroupBy=" + encodeURIComponent("" + groupBy) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEntriesGET(_response);
        });
    }

    protected processEntriesGET(response: Response): Promise<EntryListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntryListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EntryListResponse>(null as any);
    }

    /**
     * @return OK
     */
    entriesGET2(id: string): Promise<TrackingEntryDto> {
        let url_ = this.baseUrl + "/api/Entries/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEntriesGET2(_response);
        });
    }

    protected processEntriesGET2(response: Response): Promise<TrackingEntryDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrackingEntryDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrackingEntryDto>(null as any);
    }

    /**
     * @return OK
     */
    entriesPUT(id: string, body: EntryUpdateRequest): Promise<TrackingEntryDto> {
        let url_ = this.baseUrl + "/api/Entries/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEntriesPUT(_response);
        });
    }

    protected processEntriesPUT(response: Response): Promise<TrackingEntryDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrackingEntryDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrackingEntryDto>(null as any);
    }

    /**
     * @return No Content
     */
    entriesDELETE(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Entries/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEntriesDELETE(_response);
        });
    }

    protected processEntriesDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    settings(): Promise<UserSettingsDto> {
        let url_ = this.baseUrl + "/api/Settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSettings(_response);
        });
    }

    protected processSettings(response: Response): Promise<UserSettingsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserSettingsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSettingsDto>(null as any);
    }

    /**
     * @return OK
     */
    utcOffset(body: UpdateUtcOffsetRequest): Promise<UserSettingsDto> {
        let url_ = this.baseUrl + "/api/Settings/utc-offset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUtcOffset(_response);
        });
    }

    protected processUtcOffset(response: Response): Promise<UserSettingsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserSettingsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSettingsDto>(null as any);
    }

    /**
     * @return OK
     */
    autoShutdown(body: UpdateAutoShutdownRequest): Promise<UserSettingsDto> {
        let url_ = this.baseUrl + "/api/Settings/auto-shutdown";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAutoShutdown(_response);
        });
    }

    protected processAutoShutdown(response: Response): Promise<UserSettingsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserSettingsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSettingsDto>(null as any);
    }

    /**
     * @return OK
     */
    lunchReminder(body: UpdateLunchReminderRequest): Promise<UserSettingsDto> {
        let url_ = this.baseUrl + "/api/Settings/lunch-reminder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLunchReminder(_response);
        });
    }

    protected processLunchReminder(response: Response): Promise<UserSettingsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserSettingsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSettingsDto>(null as any);
    }

    /**
     * @return OK
     */
    targetHours(body: UpdateTargetHoursRequest): Promise<UserSettingsDto> {
        let url_ = this.baseUrl + "/api/Settings/target-hours";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTargetHours(_response);
        });
    }

    protected processTargetHours(response: Response): Promise<UserSettingsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserSettingsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSettingsDto>(null as any);
    }

    /**
     * @return OK
     */
    forgotThreshold(body: UpdateForgotThresholdRequest): Promise<UserSettingsDto> {
        let url_ = this.baseUrl + "/api/Settings/forgot-threshold";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForgotThreshold(_response);
        });
    }

    protected processForgotThreshold(response: Response): Promise<UserSettingsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserSettingsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSettingsDto>(null as any);
    }

    /**
     * @return OK
     */
    current(): Promise<CurrentStateResponse> {
        let url_ = this.baseUrl + "/api/Tracking/current";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCurrent(_response);
        });
    }

    protected processCurrent(response: Response): Promise<CurrentStateResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentStateResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CurrentStateResponse>(null as any);
    }

    /**
     * @return OK
     */
    toggle(body: TrackingStateRequest): Promise<TrackingStateResponse> {
        let url_ = this.baseUrl + "/api/Tracking/toggle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processToggle(_response);
        });
    }

    protected processToggle(response: Response): Promise<TrackingStateResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrackingStateResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrackingStateResponse>(null as any);
    }

    /**
     * @return OK
     */
    toggleWithOffset(body: TrackingStateWithOffsetRequest): Promise<TrackingStateResponse> {
        let url_ = this.baseUrl + "/api/Tracking/toggle-with-offset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processToggleWithOffset(_response);
        });
    }

    protected processToggleWithOffset(response: Response): Promise<TrackingStateResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrackingStateResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TrackingStateResponse>(null as any);
    }
}

export class ChartDataDto implements IChartDataDto {
    labels!: string[];
    workHours!: number[];
    commuteHours!: number[];
    lunchHours!: number[];
    idleHours!: number[];
    totalDurationHours!: number[];

    [key: string]: any;

    constructor(data?: IChartDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.labels = [];
            this.workHours = [];
            this.commuteHours = [];
            this.lunchHours = [];
            this.idleHours = [];
            this.totalDurationHours = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(item);
            }
            else {
                this.labels = null as any;
            }
            if (Array.isArray(_data["workHours"])) {
                this.workHours = [] as any;
                for (let item of _data["workHours"])
                    this.workHours!.push(item);
            }
            else {
                this.workHours = null as any;
            }
            if (Array.isArray(_data["commuteHours"])) {
                this.commuteHours = [] as any;
                for (let item of _data["commuteHours"])
                    this.commuteHours!.push(item);
            }
            else {
                this.commuteHours = null as any;
            }
            if (Array.isArray(_data["lunchHours"])) {
                this.lunchHours = [] as any;
                for (let item of _data["lunchHours"])
                    this.lunchHours!.push(item);
            }
            else {
                this.lunchHours = null as any;
            }
            if (Array.isArray(_data["idleHours"])) {
                this.idleHours = [] as any;
                for (let item of _data["idleHours"])
                    this.idleHours!.push(item);
            }
            else {
                this.idleHours = null as any;
            }
            if (Array.isArray(_data["totalDurationHours"])) {
                this.totalDurationHours = [] as any;
                for (let item of _data["totalDurationHours"])
                    this.totalDurationHours!.push(item);
            }
            else {
                this.totalDurationHours = null as any;
            }
        }
    }

    static fromJS(data: any): ChartDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChartDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item);
        }
        if (Array.isArray(this.workHours)) {
            data["workHours"] = [];
            for (let item of this.workHours)
                data["workHours"].push(item);
        }
        if (Array.isArray(this.commuteHours)) {
            data["commuteHours"] = [];
            for (let item of this.commuteHours)
                data["commuteHours"].push(item);
        }
        if (Array.isArray(this.lunchHours)) {
            data["lunchHours"] = [];
            for (let item of this.lunchHours)
                data["lunchHours"].push(item);
        }
        if (Array.isArray(this.idleHours)) {
            data["idleHours"] = [];
            for (let item of this.idleHours)
                data["idleHours"].push(item);
        }
        if (Array.isArray(this.totalDurationHours)) {
            data["totalDurationHours"] = [];
            for (let item of this.totalDurationHours)
                data["totalDurationHours"].push(item);
        }
        return data;
    }
}

export interface IChartDataDto {
    labels: string[];
    workHours: number[];
    commuteHours: number[];
    lunchHours: number[];
    idleHours: number[];
    totalDurationHours: number[];

    [key: string]: any;
}

export class CommutePatternsDto implements ICommutePatternsDto {
    dayOfWeek!: number;
    averageDurationHours!: number;
    optimalStartHour?: number | null;
    shortestDurationHours?: number | null;
    sessionCount!: number;

    [key: string]: any;

    constructor(data?: ICommutePatternsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.dayOfWeek = _data["dayOfWeek"] !== undefined ? _data["dayOfWeek"] : null as any;
            this.averageDurationHours = _data["averageDurationHours"] !== undefined ? _data["averageDurationHours"] : null as any;
            this.optimalStartHour = _data["optimalStartHour"] !== undefined ? _data["optimalStartHour"] : null as any;
            this.shortestDurationHours = _data["shortestDurationHours"] !== undefined ? _data["shortestDurationHours"] : null as any;
            this.sessionCount = _data["sessionCount"] !== undefined ? _data["sessionCount"] : null as any;
        }
    }

    static fromJS(data: any): CommutePatternsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommutePatternsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["dayOfWeek"] = this.dayOfWeek !== undefined ? this.dayOfWeek : null as any;
        data["averageDurationHours"] = this.averageDurationHours !== undefined ? this.averageDurationHours : null as any;
        data["optimalStartHour"] = this.optimalStartHour !== undefined ? this.optimalStartHour : null as any;
        data["shortestDurationHours"] = this.shortestDurationHours !== undefined ? this.shortestDurationHours : null as any;
        data["sessionCount"] = this.sessionCount !== undefined ? this.sessionCount : null as any;
        return data;
    }
}

export interface ICommutePatternsDto {
    dayOfWeek: number;
    averageDurationHours: number;
    optimalStartHour?: number | null;
    shortestDurationHours?: number | null;
    sessionCount: number;

    [key: string]: any;
}

export class CurrentStateResponse implements ICurrentStateResponse {
    state!: number;
    startedAt?: Date | null;
    durationHours?: number | null;
    commuteDirection?: number | null;

    [key: string]: any;

    constructor(data?: ICurrentStateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.state = _data["state"] !== undefined ? _data["state"] : null as any;
            this.startedAt = _data["startedAt"] ? new Date(_data["startedAt"].toString()) : null as any;
            this.durationHours = _data["durationHours"] !== undefined ? _data["durationHours"] : null as any;
            this.commuteDirection = _data["commuteDirection"] !== undefined ? _data["commuteDirection"] : null as any;
        }
    }

    static fromJS(data: any): CurrentStateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentStateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["state"] = this.state !== undefined ? this.state : null as any;
        data["startedAt"] = this.startedAt ? this.startedAt.toISOString() : null as any;
        data["durationHours"] = this.durationHours !== undefined ? this.durationHours : null as any;
        data["commuteDirection"] = this.commuteDirection !== undefined ? this.commuteDirection : null as any;
        return data;
    }
}

export interface ICurrentStateResponse {
    state: number;
    startedAt?: Date | null;
    durationHours?: number | null;
    commuteDirection?: number | null;

    [key: string]: any;
}

export class DailyAveragesDto implements IDailyAveragesDto {
    daysIncluded!: number;
    averageWorkHours!: number;
    averageCommuteToWorkHours!: number;
    averageCommuteToHomeHours!: number;
    averageLunchHours!: number;
    totalWorkDays!: number;
    averageTotalDurationHours!: number;

    [key: string]: any;

    constructor(data?: IDailyAveragesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.daysIncluded = _data["daysIncluded"] !== undefined ? _data["daysIncluded"] : null as any;
            this.averageWorkHours = _data["averageWorkHours"] !== undefined ? _data["averageWorkHours"] : null as any;
            this.averageCommuteToWorkHours = _data["averageCommuteToWorkHours"] !== undefined ? _data["averageCommuteToWorkHours"] : null as any;
            this.averageCommuteToHomeHours = _data["averageCommuteToHomeHours"] !== undefined ? _data["averageCommuteToHomeHours"] : null as any;
            this.averageLunchHours = _data["averageLunchHours"] !== undefined ? _data["averageLunchHours"] : null as any;
            this.totalWorkDays = _data["totalWorkDays"] !== undefined ? _data["totalWorkDays"] : null as any;
            this.averageTotalDurationHours = _data["averageTotalDurationHours"] !== undefined ? _data["averageTotalDurationHours"] : null as any;
        }
    }

    static fromJS(data: any): DailyAveragesDto {
        data = typeof data === 'object' ? data : {};
        let result = new DailyAveragesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["daysIncluded"] = this.daysIncluded !== undefined ? this.daysIncluded : null as any;
        data["averageWorkHours"] = this.averageWorkHours !== undefined ? this.averageWorkHours : null as any;
        data["averageCommuteToWorkHours"] = this.averageCommuteToWorkHours !== undefined ? this.averageCommuteToWorkHours : null as any;
        data["averageCommuteToHomeHours"] = this.averageCommuteToHomeHours !== undefined ? this.averageCommuteToHomeHours : null as any;
        data["averageLunchHours"] = this.averageLunchHours !== undefined ? this.averageLunchHours : null as any;
        data["totalWorkDays"] = this.totalWorkDays !== undefined ? this.totalWorkDays : null as any;
        data["averageTotalDurationHours"] = this.averageTotalDurationHours !== undefined ? this.averageTotalDurationHours : null as any;
        return data;
    }
}

export interface IDailyAveragesDto {
    daysIncluded: number;
    averageWorkHours: number;
    averageCommuteToWorkHours: number;
    averageCommuteToHomeHours: number;
    averageLunchHours: number;
    totalWorkDays: number;
    averageTotalDurationHours: number;

    [key: string]: any;
}

export class DailyBreakdownDto implements IDailyBreakdownDto {
    date!: Date;
    workHours!: number;
    commuteToWorkHours!: number;
    commuteToHomeHours!: number;
    lunchHours!: number;
    totalDurationHours?: number | null;
    hasActivity!: boolean;

    [key: string]: any;

    constructor(data?: IDailyBreakdownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.date = _data["date"] ? new Date(_data["date"].toString()) : null as any;
            this.workHours = _data["workHours"] !== undefined ? _data["workHours"] : null as any;
            this.commuteToWorkHours = _data["commuteToWorkHours"] !== undefined ? _data["commuteToWorkHours"] : null as any;
            this.commuteToHomeHours = _data["commuteToHomeHours"] !== undefined ? _data["commuteToHomeHours"] : null as any;
            this.lunchHours = _data["lunchHours"] !== undefined ? _data["lunchHours"] : null as any;
            this.totalDurationHours = _data["totalDurationHours"] !== undefined ? _data["totalDurationHours"] : null as any;
            this.hasActivity = _data["hasActivity"] !== undefined ? _data["hasActivity"] : null as any;
        }
    }

    static fromJS(data: any): DailyBreakdownDto {
        data = typeof data === 'object' ? data : {};
        let result = new DailyBreakdownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["date"] = this.date ? this.date.toISOString() : null as any;
        data["workHours"] = this.workHours !== undefined ? this.workHours : null as any;
        data["commuteToWorkHours"] = this.commuteToWorkHours !== undefined ? this.commuteToWorkHours : null as any;
        data["commuteToHomeHours"] = this.commuteToHomeHours !== undefined ? this.commuteToHomeHours : null as any;
        data["lunchHours"] = this.lunchHours !== undefined ? this.lunchHours : null as any;
        data["totalDurationHours"] = this.totalDurationHours !== undefined ? this.totalDurationHours : null as any;
        data["hasActivity"] = this.hasActivity !== undefined ? this.hasActivity : null as any;
        return data;
    }
}

export interface IDailyBreakdownDto {
    date: Date;
    workHours: number;
    commuteToWorkHours: number;
    commuteToHomeHours: number;
    lunchHours: number;
    totalDurationHours?: number | null;
    hasActivity: boolean;

    [key: string]: any;
}

export class EntryListResponse implements IEntryListResponse {
    entries!: TrackingEntryDto[];
    totalCount!: number;
    page!: number;
    pageSize!: number;
    totalPages!: number;

    [key: string]: any;

    constructor(data?: IEntryListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.entries = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["entries"])) {
                this.entries = [] as any;
                for (let item of _data["entries"])
                    this.entries!.push(TrackingEntryDto.fromJS(item));
            }
            else {
                this.entries = null as any;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : null as any;
            this.page = _data["page"] !== undefined ? _data["page"] : null as any;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : null as any;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : null as any;
        }
    }

    static fromJS(data: any): EntryListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EntryListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.entries)) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item ? item.toJSON() : null as any);
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : null as any;
        data["page"] = this.page !== undefined ? this.page : null as any;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : null as any;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : null as any;
        return data;
    }
}

export interface IEntryListResponse {
    entries: TrackingEntryDto[];
    totalCount: number;
    page: number;
    pageSize: number;
    totalPages: number;

    [key: string]: any;
}

export class EntryUpdateRequest implements IEntryUpdateRequest {
    adjustmentMinutes!: number;

    [key: string]: any;

    constructor(data?: IEntryUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.adjustmentMinutes = _data["adjustmentMinutes"] !== undefined ? _data["adjustmentMinutes"] : null as any;
        }
    }

    static fromJS(data: any): EntryUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EntryUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["adjustmentMinutes"] = this.adjustmentMinutes !== undefined ? this.adjustmentMinutes : null as any;
        return data;
    }
}

export interface IEntryUpdateRequest {
    adjustmentMinutes: number;

    [key: string]: any;
}

export class LoginRequest implements ILoginRequest {
    mnemonic!: string;

    [key: string]: any;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.mnemonic = _data["mnemonic"] !== undefined ? _data["mnemonic"] : null as any;
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["mnemonic"] = this.mnemonic !== undefined ? this.mnemonic : null as any;
        return data;
    }
}

export interface ILoginRequest {
    mnemonic: string;

    [key: string]: any;
}

export class LoginResponse implements ILoginResponse {
    accessToken!: string;
    expiresAt!: Date;
    refreshToken?: string | null;

    [key: string]: any;

    constructor(data?: ILoginResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.accessToken = _data["accessToken"] !== undefined ? _data["accessToken"] : null as any;
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : null as any;
            this.refreshToken = _data["refreshToken"] !== undefined ? _data["refreshToken"] : null as any;
        }
    }

    static fromJS(data: any): LoginResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["accessToken"] = this.accessToken !== undefined ? this.accessToken : null as any;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : null as any;
        data["refreshToken"] = this.refreshToken !== undefined ? this.refreshToken : null as any;
        return data;
    }
}

export interface ILoginResponse {
    accessToken: string;
    expiresAt: Date;
    refreshToken?: string | null;

    [key: string]: any;
}

export class PeriodAggregateDto implements IPeriodAggregateDto {
    startDate!: Date;
    endDate!: Date;
    totalWorkHours!: number;
    totalCommuteHours!: number;
    totalLunchHours!: number;
    workDaysCount!: number;
    totalDurationHours?: number | null;

    [key: string]: any;

    constructor(data?: IPeriodAggregateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : null as any;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : null as any;
            this.totalWorkHours = _data["totalWorkHours"] !== undefined ? _data["totalWorkHours"] : null as any;
            this.totalCommuteHours = _data["totalCommuteHours"] !== undefined ? _data["totalCommuteHours"] : null as any;
            this.totalLunchHours = _data["totalLunchHours"] !== undefined ? _data["totalLunchHours"] : null as any;
            this.workDaysCount = _data["workDaysCount"] !== undefined ? _data["workDaysCount"] : null as any;
            this.totalDurationHours = _data["totalDurationHours"] !== undefined ? _data["totalDurationHours"] : null as any;
        }
    }

    static fromJS(data: any): PeriodAggregateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PeriodAggregateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : null as any;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : null as any;
        data["totalWorkHours"] = this.totalWorkHours !== undefined ? this.totalWorkHours : null as any;
        data["totalCommuteHours"] = this.totalCommuteHours !== undefined ? this.totalCommuteHours : null as any;
        data["totalLunchHours"] = this.totalLunchHours !== undefined ? this.totalLunchHours : null as any;
        data["workDaysCount"] = this.workDaysCount !== undefined ? this.workDaysCount : null as any;
        data["totalDurationHours"] = this.totalDurationHours !== undefined ? this.totalDurationHours : null as any;
        return data;
    }
}

export interface IPeriodAggregateDto {
    startDate: Date;
    endDate: Date;
    totalWorkHours: number;
    totalCommuteHours: number;
    totalLunchHours: number;
    workDaysCount: number;
    totalDurationHours?: number | null;

    [key: string]: any;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"] !== undefined ? _data["type"] : null as any;
            this.title = _data["title"] !== undefined ? _data["title"] : null as any;
            this.status = _data["status"] !== undefined ? _data["status"] : null as any;
            this.detail = _data["detail"] !== undefined ? _data["detail"] : null as any;
            this.instance = _data["instance"] !== undefined ? _data["instance"] : null as any;
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type !== undefined ? this.type : null as any;
        data["title"] = this.title !== undefined ? this.title : null as any;
        data["status"] = this.status !== undefined ? this.status : null as any;
        data["detail"] = this.detail !== undefined ? this.detail : null as any;
        data["instance"] = this.instance !== undefined ? this.instance : null as any;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;

    [key: string]: any;
}

export class RefreshTokenRequest implements IRefreshTokenRequest {
    refreshToken!: string;

    [key: string]: any;

    constructor(data?: IRefreshTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.refreshToken = _data["refreshToken"] !== undefined ? _data["refreshToken"] : null as any;
        }
    }

    static fromJS(data: any): RefreshTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["refreshToken"] = this.refreshToken !== undefined ? this.refreshToken : null as any;
        return data;
    }
}

export interface IRefreshTokenRequest {
    refreshToken: string;

    [key: string]: any;
}

export class TrackingEntryDto implements ITrackingEntryDto {
    id!: string;
    state!: number;
    startedAt!: Date;
    endedAt?: Date | null;
    durationHours?: number | null;
    commuteDirection?: number | null;
    isActive!: boolean;

    [key: string]: any;

    constructor(data?: ITrackingEntryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"] !== undefined ? _data["id"] : null as any;
            this.state = _data["state"] !== undefined ? _data["state"] : null as any;
            this.startedAt = _data["startedAt"] ? new Date(_data["startedAt"].toString()) : null as any;
            this.endedAt = _data["endedAt"] ? new Date(_data["endedAt"].toString()) : null as any;
            this.durationHours = _data["durationHours"] !== undefined ? _data["durationHours"] : null as any;
            this.commuteDirection = _data["commuteDirection"] !== undefined ? _data["commuteDirection"] : null as any;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : null as any;
        }
    }

    static fromJS(data: any): TrackingEntryDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrackingEntryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id !== undefined ? this.id : null as any;
        data["state"] = this.state !== undefined ? this.state : null as any;
        data["startedAt"] = this.startedAt ? this.startedAt.toISOString() : null as any;
        data["endedAt"] = this.endedAt ? this.endedAt.toISOString() : null as any;
        data["durationHours"] = this.durationHours !== undefined ? this.durationHours : null as any;
        data["commuteDirection"] = this.commuteDirection !== undefined ? this.commuteDirection : null as any;
        data["isActive"] = this.isActive !== undefined ? this.isActive : null as any;
        return data;
    }
}

export interface ITrackingEntryDto {
    id: string;
    state: number;
    startedAt: Date;
    endedAt?: Date | null;
    durationHours?: number | null;
    commuteDirection?: number | null;
    isActive: boolean;

    [key: string]: any;
}

export class TrackingStateRequest implements ITrackingStateRequest {
    state!: number;

    [key: string]: any;

    constructor(data?: ITrackingStateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.state = _data["state"] !== undefined ? _data["state"] : null as any;
        }
    }

    static fromJS(data: any): TrackingStateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TrackingStateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["state"] = this.state !== undefined ? this.state : null as any;
        return data;
    }
}

export interface ITrackingStateRequest {
    state: number;

    [key: string]: any;
}

export class TrackingStateResponse implements ITrackingStateResponse {
    newState!: number;
    previousState?: number | null;
    message!: string;
    startedAt?: Date | null;
    previousSessionDurationHours?: number | null;

    [key: string]: any;

    constructor(data?: ITrackingStateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.newState = _data["newState"] !== undefined ? _data["newState"] : null as any;
            this.previousState = _data["previousState"] !== undefined ? _data["previousState"] : null as any;
            this.message = _data["message"] !== undefined ? _data["message"] : null as any;
            this.startedAt = _data["startedAt"] ? new Date(_data["startedAt"].toString()) : null as any;
            this.previousSessionDurationHours = _data["previousSessionDurationHours"] !== undefined ? _data["previousSessionDurationHours"] : null as any;
        }
    }

    static fromJS(data: any): TrackingStateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TrackingStateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["newState"] = this.newState !== undefined ? this.newState : null as any;
        data["previousState"] = this.previousState !== undefined ? this.previousState : null as any;
        data["message"] = this.message !== undefined ? this.message : null as any;
        data["startedAt"] = this.startedAt ? this.startedAt.toISOString() : null as any;
        data["previousSessionDurationHours"] = this.previousSessionDurationHours !== undefined ? this.previousSessionDurationHours : null as any;
        return data;
    }
}

export interface ITrackingStateResponse {
    newState: number;
    previousState?: number | null;
    message: string;
    startedAt?: Date | null;
    previousSessionDurationHours?: number | null;

    [key: string]: any;
}

export class TrackingStateWithOffsetRequest implements ITrackingStateWithOffsetRequest {
    state!: number;
    offsetMinutes!: number;

    [key: string]: any;

    constructor(data?: ITrackingStateWithOffsetRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.state = _data["state"] !== undefined ? _data["state"] : null as any;
            this.offsetMinutes = _data["offsetMinutes"] !== undefined ? _data["offsetMinutes"] : null as any;
        }
    }

    static fromJS(data: any): TrackingStateWithOffsetRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TrackingStateWithOffsetRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["state"] = this.state !== undefined ? this.state : null as any;
        data["offsetMinutes"] = this.offsetMinutes !== undefined ? this.offsetMinutes : null as any;
        return data;
    }
}

export interface ITrackingStateWithOffsetRequest {
    state: number;
    offsetMinutes: number;

    [key: string]: any;
}

export class UpdateAutoShutdownRequest implements IUpdateAutoShutdownRequest {
    maxWorkHours?: number | null;
    maxCommuteHours?: number | null;
    maxLunchHours?: number | null;

    [key: string]: any;

    constructor(data?: IUpdateAutoShutdownRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.maxWorkHours = _data["maxWorkHours"] !== undefined ? _data["maxWorkHours"] : null as any;
            this.maxCommuteHours = _data["maxCommuteHours"] !== undefined ? _data["maxCommuteHours"] : null as any;
            this.maxLunchHours = _data["maxLunchHours"] !== undefined ? _data["maxLunchHours"] : null as any;
        }
    }

    static fromJS(data: any): UpdateAutoShutdownRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAutoShutdownRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["maxWorkHours"] = this.maxWorkHours !== undefined ? this.maxWorkHours : null as any;
        data["maxCommuteHours"] = this.maxCommuteHours !== undefined ? this.maxCommuteHours : null as any;
        data["maxLunchHours"] = this.maxLunchHours !== undefined ? this.maxLunchHours : null as any;
        return data;
    }
}

export interface IUpdateAutoShutdownRequest {
    maxWorkHours?: number | null;
    maxCommuteHours?: number | null;
    maxLunchHours?: number | null;

    [key: string]: any;
}

export class UpdateForgotThresholdRequest implements IUpdateForgotThresholdRequest {
    thresholdPercent?: number | null;

    [key: string]: any;

    constructor(data?: IUpdateForgotThresholdRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.thresholdPercent = _data["thresholdPercent"] !== undefined ? _data["thresholdPercent"] : null as any;
        }
    }

    static fromJS(data: any): UpdateForgotThresholdRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateForgotThresholdRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["thresholdPercent"] = this.thresholdPercent !== undefined ? this.thresholdPercent : null as any;
        return data;
    }
}

export interface IUpdateForgotThresholdRequest {
    thresholdPercent?: number | null;

    [key: string]: any;
}

export class UpdateLunchReminderRequest implements IUpdateLunchReminderRequest {
    hour?: number | null;
    minute?: number;

    [key: string]: any;

    constructor(data?: IUpdateLunchReminderRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.hour = _data["hour"] !== undefined ? _data["hour"] : null as any;
            this.minute = _data["minute"] !== undefined ? _data["minute"] : null as any;
        }
    }

    static fromJS(data: any): UpdateLunchReminderRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLunchReminderRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["hour"] = this.hour !== undefined ? this.hour : null as any;
        data["minute"] = this.minute !== undefined ? this.minute : null as any;
        return data;
    }
}

export interface IUpdateLunchReminderRequest {
    hour?: number | null;
    minute?: number;

    [key: string]: any;
}

export class UpdateTargetHoursRequest implements IUpdateTargetHoursRequest {
    targetWorkHours?: number | null;

    [key: string]: any;

    constructor(data?: IUpdateTargetHoursRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.targetWorkHours = _data["targetWorkHours"] !== undefined ? _data["targetWorkHours"] : null as any;
        }
    }

    static fromJS(data: any): UpdateTargetHoursRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTargetHoursRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["targetWorkHours"] = this.targetWorkHours !== undefined ? this.targetWorkHours : null as any;
        return data;
    }
}

export interface IUpdateTargetHoursRequest {
    targetWorkHours?: number | null;

    [key: string]: any;
}

export class UpdateUtcOffsetRequest implements IUpdateUtcOffsetRequest {
    utcOffsetMinutes!: number;

    [key: string]: any;

    constructor(data?: IUpdateUtcOffsetRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.utcOffsetMinutes = _data["utcOffsetMinutes"] !== undefined ? _data["utcOffsetMinutes"] : null as any;
        }
    }

    static fromJS(data: any): UpdateUtcOffsetRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUtcOffsetRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["utcOffsetMinutes"] = this.utcOffsetMinutes !== undefined ? this.utcOffsetMinutes : null as any;
        return data;
    }
}

export interface IUpdateUtcOffsetRequest {
    utcOffsetMinutes: number;

    [key: string]: any;
}

export class UserSettingsDto implements IUserSettingsDto {
    utcOffsetMinutes!: number;
    maxWorkHours?: number | null;
    maxCommuteHours?: number | null;
    maxLunchHours?: number | null;
    lunchReminderHour?: number | null;
    lunchReminderMinute!: number;
    targetWorkHours?: number | null;
    forgotShutdownThresholdPercent?: number | null;

    [key: string]: any;

    constructor(data?: IUserSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.utcOffsetMinutes = _data["utcOffsetMinutes"] !== undefined ? _data["utcOffsetMinutes"] : null as any;
            this.maxWorkHours = _data["maxWorkHours"] !== undefined ? _data["maxWorkHours"] : null as any;
            this.maxCommuteHours = _data["maxCommuteHours"] !== undefined ? _data["maxCommuteHours"] : null as any;
            this.maxLunchHours = _data["maxLunchHours"] !== undefined ? _data["maxLunchHours"] : null as any;
            this.lunchReminderHour = _data["lunchReminderHour"] !== undefined ? _data["lunchReminderHour"] : null as any;
            this.lunchReminderMinute = _data["lunchReminderMinute"] !== undefined ? _data["lunchReminderMinute"] : null as any;
            this.targetWorkHours = _data["targetWorkHours"] !== undefined ? _data["targetWorkHours"] : null as any;
            this.forgotShutdownThresholdPercent = _data["forgotShutdownThresholdPercent"] !== undefined ? _data["forgotShutdownThresholdPercent"] : null as any;
        }
    }

    static fromJS(data: any): UserSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["utcOffsetMinutes"] = this.utcOffsetMinutes !== undefined ? this.utcOffsetMinutes : null as any;
        data["maxWorkHours"] = this.maxWorkHours !== undefined ? this.maxWorkHours : null as any;
        data["maxCommuteHours"] = this.maxCommuteHours !== undefined ? this.maxCommuteHours : null as any;
        data["maxLunchHours"] = this.maxLunchHours !== undefined ? this.maxLunchHours : null as any;
        data["lunchReminderHour"] = this.lunchReminderHour !== undefined ? this.lunchReminderHour : null as any;
        data["lunchReminderMinute"] = this.lunchReminderMinute !== undefined ? this.lunchReminderMinute : null as any;
        data["targetWorkHours"] = this.targetWorkHours !== undefined ? this.targetWorkHours : null as any;
        data["forgotShutdownThresholdPercent"] = this.forgotShutdownThresholdPercent !== undefined ? this.forgotShutdownThresholdPercent : null as any;
        return data;
    }
}

export interface IUserSettingsDto {
    utcOffsetMinutes: number;
    maxWorkHours?: number | null;
    maxCommuteHours?: number | null;
    maxLunchHours?: number | null;
    lunchReminderHour?: number | null;
    lunchReminderMinute: number;
    targetWorkHours?: number | null;
    forgotShutdownThresholdPercent?: number | null;

    [key: string]: any;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    throw new ApiException(message, status, response, headers, result);
}